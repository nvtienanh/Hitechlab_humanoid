#include "RobotControlThread.h"
#include "State.h"
#include "Config.h"
#include "RobotControl/Percept.h"

// The robot control thread is the main thread of the robot control architecture.
// It contains the actual robot control, that implements the classic agent function
// action = f(percept), and an interface to the physical robot. The interface is
// used to receive a percept from the robot, pass it on to the agent function and
// then to pass the action generated by the agent on to the physical robot. In this
// particular implementation, the physical robot is a bullet simulated humanoid model.
// A high precision windows multimedia timer drives the main thread by periodically
// calling the step method. Even if this class is not a QThread, due to the windows
// mm timer the step method is executed in a separate thread.
namespace indep_cpg_gait
{
	RobotControlThread::RobotControlThread(QObject *parent) : QObject(parent)
	{
		// Connect the internal timer.
		connect(&timer, SIGNAL(timeOut()), this, SLOT(step()), Qt::DirectConnection); // It must be a direct connection for it to work right!

		lastUpdateTimestamp = 0;
		lastStartTimestamp = 0;

		iface = &simulationInterface;
	//	iface = &loopbackInterface;
	}

	void RobotControlThread::init()
	{
		robotControl.init();
	}

	void RobotControlThread::reset()
	{
		simulationInterface.reset();
	}

	// Starts the robot control.
	void RobotControlThread::start()
	{
		timer.start((int)(config.systemIterationTime*1000));
		lastStartTimestamp = stopWatch.programTime();
	}

	// Stops the robot control.
	void RobotControlThread::stop()
	{
		timer.stop();
	}

	// Propagates configuration changes to the simulation interface and the robot control.
	// Config changes are coming from the gui. This slot exists so that the gui doesn't
	// have to see the internals of the RC thread, such as the robot control and the
	// simulation or robot interface.
	void RobotControlThread::configChangedIn()
	{
		simulationInterface.configChangedIn();
		bool changed = robotControl.motionLayer.motionInterfaceTest.configChangedIn();
		if (changed)
			emit configChangedOut();
	}

	// The main loop of the robot control thread. It's triggered by the timer.
	void RobotControlThread::step()
	{
		stopWatch.restart();

		// Measure how much real time passed since the last tick.
		state.time = stopWatch.time();
		state.lastIterationTime = state.time - lastUpdateTimestamp;
		lastUpdateTimestamp = state.time;

		// Get a percept from the robot (simulated or physical).
		Percept percept = iface->getPercept();

		// Give the percept to the rc.
		robotControl.sense(percept);

		// Get the action from the rc.
		Pose pose = robotControl.act();

		// Let the rc learn.
		robotControl.learn();

		// Send the pose to the robot (simulated or physical).
		iface->setPose(pose);

		// Buffer the state into history.
		state.buffer();

		// Measure execution time.
		state.lastExecutionTime = stopWatch.elapsedTime();
	}

	// Switches between the simulation interface and the loop back interface.
	void RobotControlThread::toggleInterface()
	{
		if (iface == &simulationInterface)
		{
			iface = &loopbackInterface;
			emit messageOut("Switched to loop back interface.");
		}
		else
		{
			iface = &simulationInterface;
			emit messageOut("Switched to simulation interface.");
		}
	}

	void RobotControlThread::draw()
	{
		simulationInterface.draw();
	}
}