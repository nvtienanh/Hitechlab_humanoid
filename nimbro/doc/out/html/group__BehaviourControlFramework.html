<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>NimbRo ROS Soccer Package: Behaviour Control Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_uni_bonn_ais.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">NimbRo ROS Soccer Package
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__BehaviourControlFramework.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">Behaviour Control Framework</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacebehaviourcontrol"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebehaviourcontrol.html">behaviourcontrol</a></td></tr>
<tr class="memdesc:namespacebehaviourcontrol"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace defines everything that is required for the <a class="el" href="group__BehaviourControlFramework.html">Behaviour Control Framework</a>. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section author"><dt>Author</dt><dd>Philipp Allgeuer (<a href="#" onclick="location.href='mai'+'lto:'+'pal'+'lg'+'eue'+'r@'+'ais'+'.u'+'ni-'+'bo'+'nn.'+'de'; return false;">pallg<span style="display: none;">.nosp@m.</span>euer<span style="display: none;">.nosp@m.</span>@ais.<span style="display: none;">.nosp@m.</span>uni-<span style="display: none;">.nosp@m.</span>bonn.<span style="display: none;">.nosp@m.</span>de</a>) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 21, 2014 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0.2</dd></dl>
<h1><a class="anchor" id="bcfsec1"></a>
Overview</h1>
<p>The Behaviour Control Framework (BC Framework) is a generic platform independent C++ framework designed for behaviour control on robotic platforms. It is intended for the implementation of mid- to high complexity agent behaviours. The main idea behind the framework is to separate the control task into a pool of independent behaviours, partitioned into so-called <b>behaviour layers</b>, where each behaviour can be defined to inhibit any number of other behaviours from within the same layer. The layers are generally organised in a total order of decreasing abstraction and resolution, and share information via virtual actuators and sensors, controlled by corresponding <b>actuator and sensor managers</b>. A parent <b>behaviour manager</b> links all of the layers together and implements a step routine that controls the execution of the entire structure. The layers are executed in a user-defined order, generally corresponding to the total order from highest level of abstraction to lowest level of abstraction. A key feature of the BC Framework is that multiple behaviours can concurrently be activated in each layer. An overview of the BC Framework architecture is shown in the following diagram.</p>
<div class="image">
<img src="bcf_architecture.png" alt="bcf_architecture.png"/>
<div class="caption">
Figure 1: A block diagram of the BC Framework architecture. Solid arrows indicate the object hierarchy, dashed arrows indicate the data exchange interfaces, and dotted arrows indicate sample inhibitions.</div></div>
<p>The BC Framework has been developed as a solution to the behaviour control problem that is more powerful than the <a href="http://sourceforge.net/projects/statecontroller/">State Controller Library</a> for large and complex systems. Being suitable for use in all application sizes down to the simplest of controllers is not a requirement of this framework, as it is for the State Controller Library. As such the "target markets" of the two behaviour frameworks intersect, but the frameworks do not preempt each other. The focus of the BC Framework was on the creation of a platform that would facilitate the implementation of complex behavior controllers, suitable for use on the <a href="http://www.nimbro.net/OP/">NimbRo-OP</a> and for humanoid soccer (i.e. the NimbRo-OP Soccer Behaviour package). Performance and efficiency of the framework were of high consideration, as well as its integrability and interoperability with the remaining code. Usability, structure and customizability were also of key concern.</p>
<h1><a class="anchor" id="bcfsec1a"></a>
Academic Sources</h1>
<p>The Behaviour Control Framework and the State Controller Library are detailed in the following paper.</p>
<blockquote class="doxtable">
<p>P. Allgeuer and S. Behnke, "Hierarchical and State-based Architectures for Robot Behavior
Planning and Control," in <em>Proceedings of the 8th Workshop on Humanoid Soccer Robots, IEEE-RAS Int. Conference on Humanoid Robots</em>, Atlanta, USA, 2013.</p>
<p></p>
</blockquote>
<p>You are kindly asked to cite this paper if you use this framework for academic work.</p>
<pre class="fragment">@INPROCEEDINGS{Allgeuer2013,
  author = {Philipp Allgeuer and Sven Behnke},
  title = {Hierarchical and State-based Architectures for Robot Behavior Planning and Control},
  booktitle = {Proceedings of the 8th Workshop on Humanoid Soccer Robots, IEEE-RAS Int. Conference on Humanoid Robots},
  year = {2013},
  address = {Atlanta, USA}
}
</pre><h1><a class="anchor" id="bcfsec2"></a>
Dependencies</h1>
<p>This library depends on the following external libraries (to avoid requiring C++11):</p>
<ul>
<li>Boost <a href="http://www.boost.org/doc/libs/release/libs/static_assert/">Static Assert</a></li>
<li>Boost <a href="http://www.boost.org/doc/libs/release/libs/type_traits/">Type Traits</a></li>
<li>Boost <a href="http://www.boost.org/doc/libs/release/libs/utility/">Utility</a> (specifically <a href="http://www.boost.org/doc/libs/release/libs/utility/enable_if.html">enable_if</a>)</li>
</ul>
<p>For more information, or to download the Boost Libraries, please refer to <a href="http://www.boost.org/">http://www.boost.org/</a>.</p>
<h1><a class="anchor" id="bcfsec3"></a>
Behaviour Inhibitions</h1>
<p>The inhibitions between the behaviours of each behaviour layer are processed at the beginning of program execution, before the step routine is first called. At this point the inhibition definitions are compiled into a directed acyclic graph, referred to as the <b>inhibition tree</b>. It is strictly an error if a cycle in the inhibitions exist, as this would lead to unpredictable behaviour activations. Individual inhibition definitions can be specified as being either <b>chaining</b> or <b>non-chaining</b>. The chaining inhibitions are considered to act transitively with other chaining inhibitions, leading to additional implicitly defined inhibitions, while the non-chaining inhibitions do not. Once the inhibition tree has been established, the behaviours are topologically sorted with respect to it, in order to ensure that the resolution of the inhibitions at runtime is unambiguous.</p>
<p>At the beginning of every step, each behaviour in a layer is queried for its requested activation level. This is a real number on the unit interval and is a measure of how relevant a behaviour is to the perceived current situation. A value of 1.0 corresponds to a request for complete activation, while 0.0 corresponds to complete deactivation. The activation levels are used for two purposes, to evaluate which behaviour(s) are active in a layer at any one time, and to aggregate actuator values, as discussed in the following section. The behaviours are traversed in their topological order, and the respective inhibitions are applied multiplicatively. This means for example that if a behaviour with an activation level of 0.7 inhibits another behaviour of activation level 0.9, then the latter will have its activation level reduced through multiplication by 1 - 0.7 = 0.3. In by far the most common case, this means that a behaviour with an activation level of 1.0 completely prevents all of the behaviours it inhibits from executing. In this way, the requested activation levels are refined into a set of true activation levels.</p>
<h1><a class="anchor" id="bcfsec4"></a>
Layer Data Interfaces</h1>
<p>As the hierarchy of behaviour layers are executed during a step from the top down, it is generally required that the output of higher order planning in the upper layers is made available to the lower layers. This is done using a network of virtual actuators and sensors. Each layer receives data through its sensors and delivers its output via its actuators. This is a single sender multiple receiver arrangement, where multiple sensors in multiple layers can request to receive the data from the same actuator. Actuators are uniquely identified by name, and support the use of arbitrary data types for information exchange. If the data type numerically supports it, an actuator can be made to be aggregatable. This allows multiple concurrently active behaviours to write to the same actuator. The output that is read by the corresponding sensors is then calculated as the average of the written values, weighted by activation level. This allows competing behaviours to have combined influence on an agent, provided this effect is desired.</p>
<p>In addition to the transfer of data between layers, there is usually also a need to exchange data with external sources. Most commonly this is in the form of real-world sensory perceptions and motion commands. The concept of interface layers exists for this purpose. From the perspective of the behaviour manager this is simply a normal behaviour layer with a slightly modified time of callback execution. This is necessary so that the external data can be sent and received at the appropriate times within a step. A ROS interface layer has been implemented as part of the NimbRo-OP Soccer Behaviour package, which is based on this framework. This allows communication of the behaviours node with the other nodes in the system via the inbuilt ROS topics and services. Interface layers also make it possible to split up a behaviour control system over process boundaries, meaning that multiple loop rates can be used. For example, higher-level layers can be made to execute at a slower rate than the more time-critical lower-level layers.</p>
<h1><a class="anchor" id="bcfsec4a"></a>
Initialisation and Execution Orders</h1>
<p>For a conceptual description of the initialisation order of a behaviour manager, refer to the <a class="el" href="classbehaviourcontrol_1_1BehaviourManager.html#a788e1f08b52c71c5b1ec999de2769c62">initialiseArchitecture()</a> function. For a description of the execution order, refer to the <a class="el" href="classbehaviourcontrol_1_1BehaviourManager.html#aff1644e20d696547578dd766737d3dc0">step()</a> function. Referring to the source code of each of these functions also greatly helps clarify the initialisation and step processes (see <code>behaviour_manager.cpp</code>).</p>
<p>Now suppose that we have the following behaviour architecture using the BC Framework (note that this is the automatically generated output from the <a class="el" href="classbehaviourcontrol_1_1BehaviourManager.html#af241766ea7ef2d2a85a8dd7f04ec18b5">BehaviourManager::toString()</a> function): </p>
<pre class="fragment">Defined Behaviour Architecture
==============================
The MyM behaviour manager contains:
(0) RosIL (Interface)
(1) MyL1
  (0) MyB2
  (1) MyB1
(2) MyL2
  (0) MyB3
  (1) MyB4

RosIL Layer
===========
RosIL has a sensor manager with the following sensors:
(0) MyL2/mode
(1) MyL2/count
(2) MyL2/target
RosIL has an actuator manager with the following actuators:
(0) ROS/mode
(1) ROS/targetX
(2) ROS/targetY

MyL1 Layer
==========
MyL1 has a sensor manager with the following sensors:
(0) ROS/mode
(1) ROS/targetX
(2) ROS/targetY
MyL1 has an actuator manager with the following actuators:
(0) MyL1/mode
(1) MyL1/xgoal
(2) MyL1/vgoal

MyL2 Layer
==========
MyL2 has a sensor manager with the following sensors:
(0) MyL1/mode
(1) MyL1/xgoal
(2) MyL1/vgoal
MyL2 has an actuator manager with the following actuators:
(0) MyL2/mode
(1) MyL2/count
(2) MyL2/target
</pre><p>Then the initialisation order should look like this (this is also automatically generated program output): </p>
<pre class="fragment">Initialising the architecture...
Initialising class MyM
Initialising class RosIL
Initialising class RosILSM
Initialising class RosILAM
Initialising class MyL1
Initialising class MyL1SM
Initialising class MyL1AM
Initialising class MyB2
Initialising class MyB1
Initialising class MyL2
Initialising class MyL2SM
Initialising class MyL2AM
Initialising class MyB3
Initialising class MyB4
Initialisation succeeded!
</pre><p>Now if we simulate some activation levels and actuator writes, and execute two steps of the behaviour manager we can get something like this (note that for clarity reasons, not all callback types are shown here, e.g. the actuator manager update callbacks are not shown): </p>
<pre class="fragment">Calling the step function...
  Pre-step callback in manager 'MyM'
  User-updating layer 'RosIL'
  Read 4 from the 'mode_in' ROS topic
  Read -1.5 from the 'targetX' ROS topic
  Read 5.12 from the 'targetY' ROS topic
  User-updating layer 'MyL1'
  User-updating behaviour 'MyB2'
  User-updating behaviour 'MyB1'
  Executing behaviour 'MyB2'
  Executing behaviour 'MyB1'
  Post-executing layer 'MyL1'
  User-updating layer 'MyL2'
  User-updating behaviour 'MyB3'
  User-updating behaviour 'MyB4'
  Executing behaviour 'MyB3'
  Executing behaviour 'MyB4'
  Post-executing layer 'MyL2'
  Writing 1 to the 'mode_out' ROS topic
  Writing 28 to the 'count' ROS topic
  Writing 183 to the 'target' ROS topic
  Post-executing layer 'RosIL'
  Post-step callback in manager 'MyM'
Calling the step function...
  Pre-step callback in manager 'MyM'
  User-updating layer 'RosIL'
  Read 8 from the 'mode_in' ROS topic
  Read -3 from the 'targetX' ROS topic
  Read 10.24 from the 'targetY' ROS topic
  User-updating layer 'MyL1'
  User-updating behaviour 'MyB2'
  User-updating behaviour 'MyB1'
  Executing behaviour 'MyB2'
  Executing behaviour 'MyB1'
  Post-executing layer 'MyL1'
  User-updating layer 'MyL2'
  User-updating behaviour 'MyB3'
  User-updating behaviour 'MyB4'
  Executing behaviour 'MyB3'
  Executing behaviour 'MyB4'
  Post-executing layer 'MyL2'
  Writing 1 to the 'mode_out' ROS topic
  Writing 44 to the 'count' ROS topic
  Writing 187 to the 'target' ROS topic
  Post-executing layer 'RosIL'
  Post-step callback in manager 'MyM'
Done!
</pre><p>No inhibitions were implemented in this sample architecture, but if for example <code>MyB3</code> were to inhibit <code>MyB4</code>, the <a class="el" href="classbehaviourcontrol_1_1Behaviour.html#a2bd2a2efce36fcb2943335fa156da54f">inhibited()</a> callback of the <code>MyB4</code> behaviour would execute instead of the <a class="el" href="classbehaviourcontrol_1_1Behaviour.html#a1a1ad16c6fdee6cb9cf82df7a2c72dd8">execute()</a> callback whenever <code>MyB3</code> returns that it should be activated.</p>
<h1><a class="anchor" id="bcfsec5"></a>
Miscellaneous Notes</h1>
<p>The following notes describe certain aspects of the framework in more detail.</p>
<ul>
<li>There are three main locations you can store variables within an architecture that uses the BC Framework. Note that the storage of data on global scope is not local to the behaviour manager, and hence not considered to be a viable option, apart from the fact that you should never ever do that anyway. The three types of variables are:<ul>
<li><b>Manager-shared variables:</b> These are stored inside the behaviour manager and are effectively global within the architecture, as every object in the tree has access to the behaviour manager.</li>
<li><b>Layer-shared variables:</b> These are stored inside the respective behaviour layer to which the data pertains, and is probably the most common storage location of data, as then all behaviours in the layer can access it and perform the actions they need to. Be careful when writing to layer-shared variables from behaviours, as this can lead to unexpected results if not treated carefully with consideration of the activation dynamics of the system.</li>
<li><b>Behaviour variables:</b> These are variables that are stored locally within the individual behaviours. These can be used to store and keep track of information that pertains to a single behaviour only. A procedural behaviour for instance can store at what phase of the required process it is currently in.</li>
</ul>
</li>
<li>Passing a null <code>LBase</code> or <code>MBase</code> or similar pointer into the <code>Behaviour</code> or <code>BehaviourLayer</code> or <code>Actuator</code> or <code>Sensor</code> class constructors unavoidably results in a segmentation fault as the dereferencing of these pointers needs to happen in the initialisation list... so don't do it!</li>
<li>In the <code>init()</code> functions you can safely assume that each of the parents exists and is initialised. For example, a behaviour can assume that the behaviour layer and behaviour manager have already been initialised, but should not rely on any particular initialisation order between sibling behaviours.</li>
</ul>
<h1><a class="anchor" id="bcfsec6"></a>
Code Example</h1>
<p>A (relatively) minimal example of how to use this framework is shown below. For brevity reasons, this example only defines a single layer, and with only a single child behaviour. In real applications of this framework, naturally an arbitrary number of child layers and behaviours is possible, and it is recommended that each layer and behaviour is separated into its own header/source file pair. This is beneficial for source control (e.g. git) and collaboration between multiple programmers. Also in the following example, only a single actuator and sensor are implemented. Normally these would be used to pass data between layers, but as there is only a single layer, they have been bound to each other instead. This has the effect of making the output from one step available as an input to the next step. This would normally be achieved using layer-shared variables, unless the use of aggregation is important. The behaviour in this example simply keeps incrementing four variables from throughout the architecture. To do something more useful, such as sending actuator commands in the case of a robot, it is possible to include the code directly in the behaviour. It would be highly recommended however to implement an interface layer and make use of the sensor and actuator framework. This helps to avoid possibly breaking the architecture's intended data flow model, allows the use of aggregation, and is more modular.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// File: MyCode.h</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Includes</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="behaviour__control_8h.html">behaviour_control/behaviour_control.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Namespaces</span></div>
<div class="line"><span class="keyword">using namespace </span>behaviourcontrol;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Classes</span></div>
<div class="line"><span class="keyword">class </span>MyManager;</div>
<div class="line"><span class="keyword">class </span>MyLayer;</div>
<div class="line"><span class="keyword">class </span>MyLayerSM;</div>
<div class="line"><span class="keyword">class </span>MyLayerAM;</div>
<div class="line"><span class="keyword">class </span>MyBehaviour;</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Behaviour manager</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>MyManager : <span class="keyword">public</span> <a class="code" href="classbehaviourcontrol_1_1BehaviourManager.html">BehaviourManager</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Constructor/destructor</span></div>
<div class="line">  MyManager();</div>
<div class="line">  <span class="keyword">virtual</span> ~MyManager();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Child layers</span></div>
<div class="line">  MyLayer* ML;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Function overrides (can choose to implement these)</span></div>
<div class="line">  <span class="comment">//virtual ret_t init();</span></div>
<div class="line">  <span class="comment">//virtual void preStepCallback();</span></div>
<div class="line">  <span class="comment">//virtual void postStepCallback();</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Error notification function (recommended to implement this)</span></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> reportErrorUser(<span class="keyword">const</span> std::string&amp; msg, <span class="keywordtype">bool</span> fatal, <span class="keyword">const</span> std::string&amp; funcName, <span class="keyword">const</span> std::string&amp; fileName, <span class="keywordtype">int</span> line);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Manager-shared variables</span></div>
<div class="line">  <span class="keywordtype">int</span> myVar;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Behaviour layer</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>MyLayer : <span class="keyword">public</span> <a class="code" href="classbehaviourcontrol_1_1BehaviourLayer.html">BehaviourLayer</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Constructor/destructor</span></div>
<div class="line">  <span class="keyword">explicit</span> MyLayer(MyManager* M);</div>
<div class="line">  <span class="keyword">virtual</span> ~MyLayer();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Parent manager</span></div>
<div class="line">  MyManager* <span class="keyword">const</span> M;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Sensor and actuator managers</span></div>
<div class="line">  MyLayerSM* SM;</div>
<div class="line">  MyLayerAM* AM;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Child behaviours</span></div>
<div class="line">  MyBehaviour* myBehaviour;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Function overrides (can choose to implement these)</span></div>
<div class="line">  <span class="comment">//virtual ret_t init();</span></div>
<div class="line">  <span class="comment">//virtual void update();</span></div>
<div class="line">  <span class="comment">//virtual void postExecuteCallback();</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Layer-shared variables</span></div>
<div class="line">  <span class="keywordtype">int</span> myData;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Sensor manager of behaviour layer</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>MyLayerSM : <span class="keyword">public</span> <a class="code" href="classbehaviourcontrol_1_1SensorManager.html">SensorManager</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Constructor</span></div>
<div class="line">  <span class="keyword">explicit</span> MyLayerSM(MyLayer* L) : <a class="code" href="classbehaviourcontrol_1_1SensorManager.html">SensorManager</a>(L), L(L), M(L-&gt;M)</div>
<div class="line">      , inputSig(this, <span class="stringliteral">&quot;MyLayer/outputSig&quot;</span>) <span class="comment">// &lt;-- The string needs to point to the actuator to bind to!</span></div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Parent layer and manager</span></div>
<div class="line">  MyLayer* <span class="keyword">const</span> L;</div>
<div class="line">  MyManager* <span class="keyword">const</span> M;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Layer sensors</span></div>
<div class="line">  <a class="code" href="classbehaviourcontrol_1_1Sensor.html">SensorFloat</a> inputSig;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Actuator manager of behaviour layer</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>MyLayerAM : <span class="keyword">public</span> <a class="code" href="classbehaviourcontrol_1_1ActuatorManager.html">ActuatorManager</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Constructor</span></div>
<div class="line">  <span class="keyword">explicit</span> MyLayerAM(MyLayer* L) : <a class="code" href="classbehaviourcontrol_1_1ActuatorManager.html">ActuatorManager</a>(L), L(L), M(L-&gt;M)</div>
<div class="line">      , outputSig(this, <span class="stringliteral">&quot;MyLayer/outputSig&quot;</span>, <a class="code" href="namespacebehaviourcontrol.html#a2dbc7f976961938e7655eab5c6788c3a">NOT_AGGREGATABLE</a>)</div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Parent layer and manager</span></div>
<div class="line">  MyLayer* <span class="keyword">const</span> L;</div>
<div class="line">  MyManager* <span class="keyword">const</span> M;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Layer actuators</span></div>
<div class="line">  <a class="code" href="classbehaviourcontrol_1_1Actuator.html">ActuatorFloat</a> outputSig;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Behaviour</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>MyBehaviour : <span class="keyword">public</span> <a class="code" href="classbehaviourcontrol_1_1Behaviour.html">Behaviour</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Constructor</span></div>
<div class="line">  <span class="keyword">explicit</span> MyBehaviour(MyLayer* L);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Parent layer and manager</span></div>
<div class="line">  MyLayer* <span class="keyword">const</span> L;</div>
<div class="line">  MyManager* <span class="keyword">const</span> M;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Sensor and actuator manager pointers</span></div>
<div class="line">  MyLayerSM* <span class="keyword">const</span> SM;</div>
<div class="line">  MyLayerAM* <span class="keyword">const</span> AM;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Function overrides (can choose to implement these)</span></div>
<div class="line">  <span class="comment">//virtual ret_t init();</span></div>
<div class="line">  <span class="comment">//virtual void update();</span></div>
<div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacebehaviourcontrol.html#ae49a61d4c3e238f758a90d15bb35fb58">level_t</a> computeActivationLevel();</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> execute();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Behaviour variables</span></div>
<div class="line">  <span class="keywordtype">int</span> MyVal;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// File: MyCode.cpp</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Includes</span></div>
<div class="line"><span class="preprocessor">#include &quot;MyCode.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MyManager class</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Constructor/destructor</span></div>
<div class="line">MyManager::MyManager() : BehaviourManager(<span class="stringliteral">&quot;MyManager&quot;</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Create child layers</span></div>
<div class="line">  ML = <span class="keyword">new</span> MyLayer(<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialise manager-shared variables</span></div>
<div class="line">  myVar = 0;</div>
<div class="line">}</div>
<div class="line">MyManager::~MyManager()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Delete child layers</span></div>
<div class="line">  <span class="keyword">delete</span> ML;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Error notification function</span></div>
<div class="line"><span class="keywordtype">void</span> MyManager::reportErrorUser(<span class="keyword">const</span> std::string&amp; msg, <span class="keywordtype">bool</span> fatal, <span class="keyword">const</span> std::string&amp; funcName, <span class="keyword">const</span> std::string&amp; fileName, <span class="keywordtype">int</span> line)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Display a message to the user regarding the error</span></div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;An error occurred in the behaviour architecture!&quot;</span> &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; (fatal ? <span class="stringliteral">&quot;Fatal error: &quot;</span> : <span class="stringliteral">&quot;Non-fatal error: &quot;</span>) &lt;&lt; msg &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;In function &quot;</span> &lt;&lt; funcName &lt;&lt; <span class="stringliteral">&quot;()&quot;</span> &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; <span class="stringliteral">&quot;line &quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; fileName &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Exit the application if a fatal error (or whatever the appropriate response is that stops the behaviour manager from executing further)</span></div>
<div class="line">  <span class="keywordflow">if</span>(fatal) MyExitApplicationFn(EXIT_FAILURE);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MyLayer class</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Constructor/destructor</span></div>
<div class="line">MyLayer::MyLayer(MyManager* M) : BehaviourLayer(M, <span class="stringliteral">&quot;MyLayer&quot;</span>), M(M)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Create sensor and actuator managers</span></div>
<div class="line">  SM = <span class="keyword">new</span> MyLayerSM(<span class="keyword">this</span>);</div>
<div class="line">  AM = <span class="keyword">new</span> MyLayerAM(<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create child behaviours</span></div>
<div class="line">  myBehaviour = <span class="keyword">new</span> MyBehaviour(<span class="keyword">this</span>); <span class="comment">// Refer to the MyBehaviour constructor: The behaviours *must* be constructed after the sensor and actuator managers!</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Add inhibitions</span></div>
<div class="line">  <span class="comment">// &lt;-- No inhibitions yet as only one behaviour --&gt;</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialise layer-shared variables</span></div>
<div class="line">  myData = 0;</div>
<div class="line">}</div>
<div class="line">MyLayer::~MyLayer()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Delete child behaviours</span></div>
<div class="line">  <span class="keyword">delete</span> myBehaviour;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Delete sensor and actuator managers</span></div>
<div class="line">  <span class="keyword">delete</span> SM;</div>
<div class="line">  <span class="keyword">delete</span> AM;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MyBehaviour class</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Constructor</span></div>
<div class="line">MyBehaviour::MyBehaviour(MyLayer* L) : Behaviour(L, <span class="stringliteral">&quot;MyBehaviour&quot;</span>), L(L), M(L-&gt;M), SM(L-&gt;SM), AM(L-&gt;AM) <span class="comment">// Note: As MyBehaviour receives a pointer to the sensor and actuator managers of the parent layer (a recommended practice), the corresponding managers have to be created before the behaviours in the layer constructor!</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Initialise behaviour variables</span></div>
<div class="line">  myVal = 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Function overrides</span></div>
<div class="line"><a class="code" href="namespacebehaviourcontrol.html#ae49a61d4c3e238f758a90d15bb35fb58">level_t</a> MyBehaviour::computeActivationLevel()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Return that the behaviour is always requesting activation (no inhibitions =&gt; will always end up being activated)</span></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> MyBehaviour::execute()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Increment various variables</span></div>
<div class="line">  myVal++;</div>
<div class="line">  L-&gt;myData++;</div>
<div class="line">  M-&gt;myVar++;</div>
<div class="line">  <span class="keywordtype">int</span> input = SM-&gt;inputSig.read()</div>
<div class="line">  AM-&gt;outputSig.write(input + 1, <span class="keyword">this</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>See <code><a class="el" href="test__behaviour__control_8h_source.html">test/test_behaviour_control.h</a></code> and <code>test/test_behaviour_control.cpp</code> for more examples of how to define and run behaviours, layers and managers.</p>
<p>See <code><a class="el" href="behaviour__control_8h.html" title="Implements the Behaviour Control Framework. ">behaviour_control.h</a></code> and <code>behaviour_control.cpp</code> (and the therein included header files) for the framework source code.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacebehaviourcontrol.html">behaviourcontrol Namespace </a> </dd>
<dd>
<a class="el" href="classbehaviourcontrol_1_1BehaviourManager.html">BehaviourManager Class </a> </dd>
<dd>
<a class="el" href="classbehaviourcontrol_1_1BehaviourLayer.html">BehaviourLayer Class </a> </dd>
<dd>
<a class="el" href="classbehaviourcontrol_1_1Behaviour.html">Behaviour Class </a> </dd></dl>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Aug 26 2016 07:56:25 for NimbRo ROS Soccer Package by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
